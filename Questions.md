- АРХИТЕКТУРА!!! 
   - после нескольких итераций пришел к гексогональной архитектуре но с use-кейсами и доменной областью,
    как средством деления логики приложения. 
     в учебном приложении получилиcь области
         - работа с бэкапом
         - администривные операции(пока только ping)
         - работа с метриками

    ПРИМ. После нескольких итераций и размышлений осознал что не очень понимаю разницу между гексогональной архитектурой и clean архитектурой.
    В проекте use-кейса + доменная область; но названия пакетов как в гексогональной архитектуре 
    

    На сколько логично выглядит проект со стороны? 
    Как вообще оформляются проекты? Добавляют ли обычно какие-то схемы/диаграммы/README.md; 
    Как обычно описывается сервис/создается/поддерживается документация для дальнейшего использования (go doc, dokka ??? );

- Логирование в проекте - что логировать, как логировать; как проверять что разработчики не косячат (может средства автоматизации есть; (прим. вопрос становится критичным, если для разбора логов применяются различные системы аналиики))

- storage/wrapper/retriable.go - может есть более изящное решение? 
  (смущает некоторое дублирование кода и создание функциональные оберток в теле функций (будет ли при каждом вызове создаваться новая анонимная функция или компилятор оптимизирует такие вещи?))

- Надо ли писать w.WriteHeader(http.StatusOK); 
  Вроде как "почему нет" (Александр Передерей (при. Александр проверял у меня второй спринт; я его понял именно так, но возможности переспросить не было)):
    После разных экспериментов с w.Header().Set(...), w.WriteHeader и  w.Write(..) сложилась следующая картина:
    (с учетом того что в http сначала идет start-line с кодом ответа, потом хедеры, потом тело получается)
       - w.Header().Set/Add работают только до вызова w.WriteHeader или w.Write(..)
       - если WriteHeader не был вызван, то используется значение 200
       - если Content-Type не был установлен до вызова w.WriteHeader или w.Write(..) то будет записано значение text/plain
    При этом:
      код
        w.Header().Set("Content-Type", "hello")
	      w.WriteHeader(http.StatusForbidden)

	      w.Header().Set("Content-Type2", ApplicationJSON)
	      w.WriteHeader(http.StatusBadGateway)

	      w.Write([]byte("BEFORE ERROR"))
	      http.Error(w, "TEST ERROR", http.StatusBadRequest)

      выдает через curl:
        * Mark bundle as not supporting multiuse
        * < HTTP/1.1 403 Forbidden
        * HTTP/1.1 403 Forbidden
        * < Content-Type: hello
        * Content-Type: hello
        * < Date: Fri, 22 Mar 2024 21:05:39 GMT
        * Date: Fri, 22 Mar 2024 21:05:39 GMT
        * < Content-Length: 23
        * Content-Length: 23

        * < 
        * BEFORE ERRORTEST ERROR
        * Connection #0 to host localhost left intact
      Зато текущая реализация loggingResponseWriter выдает 
        logging/logging_response_info_mw.go:49  requestResult	{"statusCode": 400, "size": 23} !!!!!!!
  Прим 1. Не хочу показаться занудой, просто при обработке больших по размеру сообщений вопрос кэширования ответа становиться очень интересным

- middleware/testutils/http_handler.go - добавил Handler интерфейс ради генерации mock. Можно ли как-то заставить gomock сгенерировать mock для стандартного интерфейса http.Handler (прим. в данном месте можно и обойтись).

- defer req.Body.Close() в http-хэндлере: 
  В документации (https://pkg.go.dev/net/http#Request):
    The Server will close the request body. The ServeHTTP Handler does not need to.
  Получается что можно не заморачиваться с закрытием?
  
- DOCKER - было бы логично добавить тестирование storage на postgres, но смущает реализация unit-тестов и для локального запуска и в связке с github metricstest.  (появляются вопросы по реализации - можно ли завязаться на переменные окружение  POSTGRES_PASSWORD: postgres, POSTGRES_DB: praktikum и т.д). Возможно будет использование docker в кусре далее? Стоит ли сейчас заниматься?


