- АРХИТЕКТУРА!!! 
    После нескольких итераций и размышлений осознал что не очень понимаю разницу между гексогональной архитектурой и clean архитектурой.
    В проекте use-кейсы(разбиты на области) + доменная область; но названия пакетов как в гексогональной архитектуре 
    в учебном приложении получилиcь области
         - работа с бэкапом
         - администривные операции(пока только ping)
         - работа с метриками
    На сколько логично выглядит проект со стороны? 

- Документация на проект
    Как вообще оформляются проекты?
    Как обычно описывается сервис/создается/поддерживается документация для дальнейшего использования (go doc, dokka, схемы/диаграммы/README.md );

- Логирование в проекте - что логировать, как логировать; как проверять что разработчики не косячат (может средства автоматизации есть; (прим. вопрос становится критичным, если для разбора логов применяются различные системы аналиики))

- Надо ли писать w.WriteHeader(http.StatusOK); 
  Вроде как "почему нет"?
  но после разных экспериментов с w.Header().Set(...), w.WriteHeader и  w.Write(..) сложилась следующая картина:
    (с учетом того что в http сначала идет start-line с кодом ответа, потом хедеры, потом тело получается)
       - w.Header().Set/Add работают только до вызова w.WriteHeader или w.Write(..) (может пропутил, в теории было про только про w.Write(..))
       - если WriteHeader не был вызван, то используется значение http.StatusOK
       - если WriteHeader был вызвано - повторный вызов не повиляет
       - если Content-Type не был установлен до вызова w.WriteHeader или w.Write(..) то будет записано значение text/plain
      Пришлось вность доработку в logging_response_info_mw
      Убрал w.WriteHeader(http.StatusOK) в конце методов как бессмысленные
  Прим  Не хочу занудствовать, просто при обработке больших по размеру сообщений вопрос внутреннего кэширования ответа становится актуальным

- storage/wrapper/retriable.go - может есть более изящное решение? 
  (смущает некоторое дублирование кода и создание функциональные оберток в теле функций (будет ли при каждом вызове создаваться новая анонимная функция или компилятор оптимизирует такие вещи?))

- middleware/testutils/http_handler.go - добавил Handler интерфейс ради генерации mock. Можно ли как-то заставить gomock сгенерировать mock для стандартного интерфейса http.Handler (прим. в данном месте можно и обойтись).

- defer req.Body.Close() в http-хэндлере: 
  В документации (https://pkg.go.dev/net/http#Request):
    The Server will close the request body. The ServeHTTP Handler does not need to.
  Получается что можно не заморачиваться с закрытием?
  
- DOCKER - было бы логично добавить тестирование storage на postgres, но смущает реализация unit-тестов и для локального запуска и в связке с github metricstest.  (появляются вопросы по реализации - можно ли завязаться на переменные окружение  POSTGRES_PASSWORD: postgres, POSTGRES_DB: praktikum и т.д). Возможно будет использование docker в кусре далее? Стоит ли сейчас заниматься?


